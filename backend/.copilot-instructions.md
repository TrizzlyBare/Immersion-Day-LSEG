# GitHub Copilot Instructions for LSEG Immersion Day Travel Plan API

## Project Overview

This is a **simplified FastAPI backend** for the LSEG Immersion Day project that generates AI-powered travel itineraries. The API accepts only **2 inputs**: `country` and `days`, and returns comprehensive travel plans generated using Gemini AI.

## Key Architecture & Design Principles

### 1. **Minimal Input Philosophy**

- Only accept `country` (string) and `days` (integer, 1-30)
- No complex preferences, budget tiers, or date constraints
- Keep the user experience as simple as possible

### 2. **Project Structure**

```
backend/
├── app/
│   ├── api/api_v1/endpoints/travelplans.py  # Main API endpoints
│   ├── schemas/travelplan.py                # Pydantic models
│   ├── services/gemini_service.py           # AI integration service
│   ├── core/config.py                       # Configuration settings
│   └── main.py                              # FastAPI application
├── requirements.txt                         # Dependencies
├── .env                                     # Environment variables
└── API_DOCUMENTATION.md                     # API documentation
```

### 3. **Core Data Models**

- `TravelPlanInput`: Simple input with country and days only
- `TravelPlan`: Complete travel plan with itinerary and metadata
- `DayItinerary`: Daily activities, costs, and timing
- `GeminiGenerationResponse`: AI service response wrapper

## Development Guidelines for Copilot

### When working on this project, please:

#### **API Endpoints**

- Keep endpoints RESTful and simple
- Use clear, descriptive endpoint names
- Always include proper HTTP status codes and error handling
- Validate input at the endpoint level
- Use Pydantic models for request/response validation

#### **Code Style**

- Use Python type hints consistently
- Follow FastAPI best practices
- Keep functions focused and single-purpose
- Use descriptive variable and function names
- Include docstrings for all public functions

#### **Error Handling**

- Use HTTPException for API errors
- Provide clear, user-friendly error messages
- Log errors appropriately for debugging
- Handle edge cases gracefully

#### **AI Integration**

- Keep Gemini AI calls simple and focused
- Include fallback mechanisms for AI failures
- Mock AI responses during development/testing
- Structure prompts clearly and consistently

## Current API Endpoints

### Core Endpoints

1. `POST /api/v1/travel-plans/generate` - Generate travel plan with Gemini AI
2. `GET /api/v1/travel-plans/` - List all travel plans
3. `GET /api/v1/travel-plans/{id}` - Get specific travel plan
4. `POST /api/v1/travel-plans/validate` - Validate input before generation

### Example Request/Response

```python
# Request
{
  "country": "Japan",
  "days": 5
}

# Response
{
  "success": true,
  "travel_plan": {
    "id": 1,
    "country": "Japan",
    "days": 5,
    "title": "Amazing 5-Day Japan Adventure",
    "description": "Experience the best of Japan...",
    "total_estimated_cost": 500,
    "currency": "USD",
    "itinerary": [
      {
        "day_number": 1,
        "title": "Day 1: Arrival & Introduction",
        "activities": [...],
        "estimated_cost": 100
      }
    ],
    "created_at": "2025-10-03T00:00:00",
    "gemini_generated": true
  },
  "generation_time_seconds": 1.2
}
```

## Code Patterns to Follow

### 1. **Endpoint Pattern**

```python
@router.post("/endpoint-name", response_model=ResponseModel)
async def function_name(input_data: InputModel):
    """Clear description of what this endpoint does"""
    try:
        # Validation
        if not input_data.field:
            raise HTTPException(status_code=400, detail="Field is required")

        # Business logic
        result = await service.process(input_data)

        # Return response
        return ResponseModel(success=True, data=result)

    except HTTPException:
        raise
    except Exception as e:
        return ResponseModel(success=False, error_message=str(e))
```

### 2. **Service Pattern**

```python
class ServiceName:
    """Service for handling specific business logic"""

    def __init__(self):
        self.config = settings

    async def process_data(self, input_param: str) -> OutputType:
        """Process data and return result"""
        # Implementation here
        return result
```

### 3. **Schema Pattern**

```python
class InputModel(BaseModel):
    """Description of input model"""
    field: str = Field(..., description="Field description")

    # Validation methods if needed
    @field_validator("field")
    @classmethod
    def validate_field(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Field cannot be empty")
        return v
```

## Environment & Configuration

### Required Environment Variables

```bash
# Core API settings
DEBUG=True
API_V1_STR="/api/v1"
PROJECT_NAME="LSEG Immersion Day API"
SECRET_KEY="your-secret-key"

# Gemini AI settings
GEMINI_API_KEY="your-gemini-api-key"
GEMINI_MODEL="gemini-pro"
```

### Dependencies

- FastAPI for web framework
- Pydantic for data validation
- Uvicorn for ASGI server
- Google Generative AI for Gemini integration

## Testing Guidelines

### Test Structure

```python
def test_endpoint_name():
    """Test description"""
    # Arrange
    input_data = {"country": "Japan", "days": 5}

    # Act
    response = client.post("/api/v1/travel-plans/generate", json=input_data)

    # Assert
    assert response.status_code == 200
    assert response.json()["success"] is True
```

### Key Test Cases

- Valid input scenarios
- Invalid input handling (empty country, days > 30)
- AI service integration
- Error handling and edge cases

## Deployment Considerations

### Development

```bash
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

### Production

- Use proper secret management
- Configure CORS for frontend integration
- Add rate limiting for AI API calls
- Implement proper logging and monitoring

## Common Pitfalls to Avoid

1. **Don't overcomplicate the input model** - stick to country and days only
2. **Don't add unnecessary dependencies** - keep the stack minimal
3. **Don't skip input validation** - always validate at the API boundary
4. **Don't ignore error handling** - provide meaningful error messages
5. **Don't hardcode configuration** - use environment variables

## Integration Notes

- Frontend should call `/generate` endpoint with simple JSON payload
- Response includes complete travel plan ready for display
- All costs are in USD (configurable in future)
- AI generation typically takes 1-3 seconds
- Plans are stored in memory (demo) - implement database for production

## Future Enhancements (Consider When Extending)

- Database integration (PostgreSQL/MongoDB)
- User authentication and plan ownership
- Real-time generation status updates
- Export functionality (PDF, email)
- Multi-language support
- Currency conversion
- Offline plan storage

---

**Remember**: This is a demo project focused on simplicity and AI integration. Keep the code clean, well-documented, and maintainable while showcasing the power of AI-generated travel planning with minimal user input.
